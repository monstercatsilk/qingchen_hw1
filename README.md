# algebra
硬件技术团队编程基础作业
## 实现思路 | Thinking
* **加法，减法，乘法和数乘**

  加法，减法和数乘都通过建立两个for嵌套循环，遍历矩阵的每一个元素，并在新建的矩阵中每个对应位置计算并赋值。乘法相对复杂些，要在新建矩阵的每个位置额外进行两次for循环，遍历第一个矩阵对应行的元素和第二个矩阵对应列的元素。

  以下依次为加法、减法、乘法、数乘的实现：

  ![加法](https://qingchen-1357753805.cos.ap-nanjing.myqcloud.com/%E5%8A%A0%E6%B3%95.png)  

  ![减法](https://qingchen-1357753805.cos.ap-nanjing.myqcloud.com/%E5%87%8F%E6%B3%95.png)

  ![乘法](https://qingchen-1357753805.cos.ap-nanjing.myqcloud.com/%E4%B9%98%E6%B3%95.png)

  ![数乘](https://qingchen-1357753805.cos.ap-nanjing.myqcloud.com/%E6%95%B0%E4%B9%98.png)

* **转置**

  先新建一个矩阵，其行数与列数分别等于原矩阵的列数与行数，随后用for循环遍历原矩阵的元素并为新矩阵的元素赋值即可。

  ![转置](https://qingchen-1357753805.cos.ap-nanjing.myqcloud.com/%E8%BD%AC%E7%BD%AE.png)

* **行列式和逆**

  行列式运用递归原理来计算。在矩阵为方阵的情况下，若其为一阶方阵，则其行列式值为其唯一的元素。若其阶数大于1，则对第0行运用拉普拉斯公式。先建立一个大的for循环结构，每次循环开始时都新建一个矩阵（即原矩阵删除第0行和第i行得到的（n-1）阶方阵），在这里运用递归，在总和上加上这个（n-1）阶行列式乘(-1) ^ (i+j)（即a[0] [i]的代数余子式）。遍历整个第0行之后得到的总和就是n阶行列式的值。

​	![行列式](https://qingchen-1357753805.cos.ap-nanjing.myqcloud.com/%E8%A1%8C%E5%88%97%E5%BC%8F.png)

​	上面给出了余子式的求法，借此可以求出原矩阵的伴随矩阵。若原方阵行列式不为0，则对伴随矩阵每个元素除以这个行列式就能得	到逆矩阵。

​	![逆](https://qingchen-1357753805.cos.ap-nanjing.myqcloud.com/%E9%80%86.png)

* **秩**

  秩的求法还是困扰了我一段时间的。大致思路就是把矩阵化为上三角形式。

  首先，从i=0开始，对a[i] [i]，从该元素开始向下遍历，依次判断其下方的元素是否为0，将其所在行与其以下（含自身）第一个非0元素所在行的所有元素交换。如果其以下的元素全为0，就把最后一列的元素依次赋值给这一列，然后矩阵总列数减1（相当于删掉这一列），重新对这一列进行上述操作。

  然后进行高斯消元。将这个a[i] [i]以下的元素全部通过行变换变为0，但是要特别注意，行变换必须从右往左进行（因为如果左边的元素提前变为0会对右边的计算产生影响，我就是因为没注意这一点才卡在这里很久）。

  当i=m或i=n时，矩阵已经处理完成，接下来计算主对角线不为0的元素个数即可。

  ![秩](https://qingchen-1357753805.cos.ap-nanjing.myqcloud.com/%E7%A7%A9.png)

* **迹**

  这个没什么好说的，如果是方阵，直接对其主对角线元素求和即可。

  ![迹](https://qingchen-1357753805.cos.ap-nanjing.myqcloud.com/%E8%BF%B9.png)



**最后给出两个报错的案例：**

![报错1](https://qingchen-1357753805.cos.ap-nanjing.myqcloud.com/%E6%8A%A5%E9%94%991.png)

![报错2](https://qingchen-1357753805.cos.ap-nanjing.myqcloud.com/%E6%8A%A5%E9%94%992.png)
